---
title: 'Marionette: Adding data to your app'
author: Kaleb Clark
layout: post
permalink: /marionette-adding-data-to-your-app/
main_image:
  - 
categories:
  - blog
---
Now that we have an application stack generated by the generator, we can start adding views and controllers.

We will look at adding a simple data structure that will have a [model][1], [collection][2], [collectionView][3], [itemView][4] and a form to input data.

The model and collection are both part of the base Backbone framework. collectionView and ItemView are Marionette specific.

**Note**: When we create these using yo, they are only placed in the file structure. They are **not** added to the application stack. We will have to do that manually.

**Creating the model & collection:**  
A collection is a collection of models. Models are single row level elements, while collections are many rows of the model. If we think of it this way, it makes sense to create the model & collection at the same time. Yo can do this for us:

<pre class="brush: bash; title: ; notranslate" title="">$ yo marionette:collection users --model user --create-all
   create scripts/collections/users.js
   invoke   marionette:model
   create     scripts/models/user.js
</pre>

**Note**: Seems like good practice to name the collection the plural of the model. {collection: users, model: user}

**Creating the views:**  
Views can be tied directly to the collection and model. For a model view, marionette uses ItemView. Collections use CollectionView. ItemViews render each model, while collectionViews render the entire collection of models. In Marionette, by rendering the CollectionView, it automatically renders the ItemView models.

<pre class="brush: bash; title: ; notranslate" title="">$ yo marionette:collectionview users-view --itemview user-view --create-all
   create scripts/views/collection/users-view.js
   invoke   marionette:itemview
   create     scripts/views/item/user-view.js
   invoke       marionette:tmpl
   create         templates/item/user-view_tmpl.hbs
</pre>

Note that this has also created a template in templates/item/ called userView_tmpl.hbs for the ItemView user-view, but did **not** create a template for the CollectionView users-view. This is because the CollectionView renders the ItemViews from userView and does not need a template for itself.

Reference: [CollectionView:EmptyView][5]. Will render when there are no items in the view.

**Creating the form:**  
The form view will be a marionette ItemView. yo can do this for us as well.

<pre class="brush: bash; title: ; notranslate" title="">$ yo marionette:itemview user-form --create-all
   create scripts/views/item/userForm.js
   invoke   marionette:tmpl
   create     templates/item/userForm_tmpl.hbs
</pre>

The itemview created a template for us.

**Putting it all together:**  
Now comes the manual part of putting it all together. We must initialize the collection in the application and render it.

Since we created everything through yo, its pretty much all tied together for us.

scripts/application.js &#8211; We need to add the collection, users-view and form-view. In the &#8220;define&#8221; and main function.

<pre class="brush: jscript; title: File: scripts/application.js; notranslate" title="File: scripts/application.js">define([
  'backbone',
  'communicator',
  'collections/users',             /* Collection users */
  'views/collection/users-view',   /* CollectionView users-view */
  'views/item/user-form'           /* ItemView user-form */
],

function( Backbone, Communicator, Users, UsersView, UserForm ) {
  ...
</pre>

The define needs to refer to the actual script name (minus the .js), and function reference is arbitrary. Its one to one, define => function. ie: &#8216;collection/users&#8217; => Users, &#8216;views/item/user-form&#8217; => UserForm. These function definitions can now be called in the main function, and will load the referenced script.

Setup the regions in scripts/application.js

<pre class="brush: jscript; title: ; notranslate" title="">App.addRegions({
  userForm: '#user-form',
  userList: '#user-list'
});
</pre>

Of course, you will have to put the &#8216;#user-form&#8217; and &#8216;#user-list&#8217; in your index.html somewhere.

Setup the initializers in scripts/application.js

<pre class="brush: jscript; title: ; notranslate" title="">App.addInitializer( function () {
    /* Call the users Collection */
    App.users = new Users();

    /* Call and bind user-form ItemView to region 'userForm' */
    App.userForm.show( new FormView({collection: App.users}));

    /* Call and bind users-view CollectionView to region 'userList' */
    App.userList.show( new UsersView({collection: App.users}));

    Communicator.mediator.trigger("APP:START");
  });
</pre>

Line 3 calls the users Collection. This adds the users Collection to the application  
Line 6 calls the user-form ItemView. This binds the ItemView to the region &#8216;userForm&#8217;.  
Line 9 calls the users-view CollectionView. This binds the CollectionView to the region &#8216;userList&#8217;.

**Setting up events in the form:**  
Now we have to setup the events in the form. These are located in the ItemView for the form scripts/views/item/user-form.js.

Marionette makes this very easy for us. Instead of having to fetch values from form elements each time we want to use them, Marionette has an object for this called &#8216;ui&#8217;. We can add references to the form elements in the ui object.

<pre class="brush: jscript; title: ; notranslate" title="">ui: {
  name: '#name',
  dob:  '#dob'
},
</pre>

Now these are tied to the main object as this.ui.name, and this.ui.dob.

Firing the add user event from a button:  
Thanks, Marionette for making this easy! First we add the button selector to the events object.

<pre class="brush: jscript; title: ; notranslate" title="">events: {
  'click button': 'addNewUser'
}
</pre>

This ties the button click event to the &#8216;addNewUser&#8217; function we will create next. Put the following code just after the &#8216;events&#8217; object.

<pre class="brush: jscript; title: ; notranslate" title="">addNewUser: function() {
  this.collection.add({
    name: this.ui.name.val(),
    dob:  this.ui.dob.val()
  });
  this.ui.name.val('');   /* Clears the form */
  this.ui.dob.val('');    /* Clears the form */
}
</pre>

The add method on the collection accepts JSON formatted values. In this case, we are pulling the form values from the &#8216;ui&#8217; object.

**Setting up the templates:**  
The templates/item/user-form_tmpl.hbs file needs to have <input> elements with id&#8217;s from the &#8216;ui&#8217; object, as well as a button for the addNewUser event.

<pre class="brush: xml; title: ; notranslate" title="">&lt;input type="text" id="name" /&gt;&lt;br/&gt;
&lt;input type="text" id="dob" /&gt;&lt;/br&gt;
&lt;button&gt;Add New User&lt;/button&gt;
</pre>

The templates/item/user-view_tmpl.hbs file will render individual user-view models. It can reference the model by attribute wrapped in {{ attrName }}. This is part of the handlebars plugin.

<pre class="brush: xml; title: ; notranslate" title="">&lt;div&gt;
  &lt;span&gt;{{ name }}&lt;/span&gt;
  &lt;span&gt;{{ dob }}&lt;/span&gt;
&lt;/div&gt;
</pre>

Thats it! run it!

 [1]: http://backbonejs.org/#Model
 [2]: Collection
 [3]: https://github.com/marionettejs/backbone.marionette/blob/master/docs/marionette.collectionview.md
 [4]: https://github.com/marionettejs/backbone.marionette/blob/master/docs/marionette.itemview.md
 [5]: https://github.com/marionettejs/backbone.marionette/blob/master/docs/marionette.collectionview.md#collectionviews-emptyview